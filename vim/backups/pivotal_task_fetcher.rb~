module PivotalTaskFetcher
  include PivotalFetcher
  
  def to_sprint iteration, team
    build_sprint(iteration) do |sprint|
      memo = iteration['stories'].inject({}) do |memo, story|
        memo[story] = story['tasks'] || []
        memo
      end
      sprint.total_points = total_points memo
      from_db = db_sprint team, sprint
      memo.each do |story, tasks|
        if empty_story? story, tasks, from_db
          sprint.pivotal_progresses << to_story_progress(story)
        else
          tasks.select{ |t| t['complete'] }.each do |t|
            sprint.pivotal_progresses << to_progress(story, t, from_db){ from_db.today if from_db } 
          end
        end
      end
    end 
  end
  
  def total_points stories
    stories.keys.inject(0) do |sum, story|
     tasks = stories[story]
     tasks.length > 0 ? sum + tasks.length : sum + 1 
    end
  end

  def empty_story? story, tasks, db_sprint 
    #Think this makes no sense to verify db_progresses here
    db_progresses = db_sprint.nil? ? [] : db_sprint.pivotal_progresses 
    story['current_state'] == 'accepted' && db_progresses.empty? && tasks.empty?
  end

  def db_sprint team, sprint
    db_team = user.pivotal_teams.detect{|t| t.integration_id == team.integration_id }
    if db_team
      db_sprint = db_team.pivotal_sprints.detect{|s| s.integration_id == sprint.integration_id } 
    else
      db_sprint = nil
    end
    db_sprint
  end

  def to_story_progress story
    description = task_description story['name'], story['story_type']
    apply_date = story['current_state'] == 'accepted' ? story['accepted_at'].to_date : nil
    PivotalProgress.new(apply_date: apply_date, points: 1, description: description, integration_id: story['id'].to_s)
  end

  def to_progress story, task, related_progress = nil
    apply_date = block_given? ? yield || Date.today : Date.today
    apply_date = related_progress.apply_date if related_progress
    description = task_description story['name'], story['story_type'], task['description']
    PivotalProgress.new(apply_date: apply_date, points: 1, integration_id: task['id'].to_s, description: description)
  end

  @@max_mid_desc_length = 125 
  def task_description story_name, story_type, task_description = nil
    story_description = story_name || ""
    task_description = task_description || ""
    identifier = story_type_identifier story_type

    length_pad = length_pad task_description
    max_length = @@max_progress_length - (identifier.length + length_pad)
    mid_length = (max_length / 2).floor

    if story_description.length + task_description.length < max_length 
      format_description story_description, identifier, task_description
    elsif task_description.length > mid_length && story_description.length < mid_length 
      max_task_length = max_length - story_description.length 
      format_description story_description, identifier, task_description[0...max_task_length]
    elsif story_description.length > mid_length && task_description.length < mid_length 
      max_story_length = max_length - task_description.length 
      format_description story_description[0...max_story_length], identifier, task_description
    else
      max_length = @@max_mid_desc_length - ((identifier.length + length_pad) / 2).ceil

      format_description story_description[0...max_length], identifier, task_description[0...max_length]
    end
  end 
  def length_pad task
    task.blank? ? 2 : 3
  end

  def format_description story, identifier, task
    if task.blank?
      "#{identifier} #{story}"
    else
      "#{identifier} #{story}, #{task}"
    end
  end

  def fetch_iterations project_id
    @fetch_iterations[project_id] ||= lambda{
      response = RestClient.get "#{api_url}/projects/#{project_id}/iterations/current", request_header
      Hash.from_xml(response)['iterations'].compact
    }.call
  end
end
