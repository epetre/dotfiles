class PivotalHelper
  include PivotalRequester

  attr_accessor :host, :token

  def initialize options={}
    self.host = options[:host]
    self.token = option[:token]
  end

  def available_team_integration_ids
    @available_ids ||= lambda do  
      projects = Hash.from_xml(RestClient.get "#{api_url}/projects", request_header)['projects']
      projects = projects ? projects.compact : [] 
      projects.collect{|p| [p['name'], p['id']]} 
    end.call
  end
end

class Fetcher
  attr_accessor :user, :options
  # for pivotal
  attr_accessor :host, :token, :sync_count, :projects_filter

  class << self
    alias_method :new_orig, :new unless respond_to? :new_orig

    def new(*args)
      obj = new_orig *args
      user = args[0]
      case user.preference_sheet.sync_type
      when 1 then obj.extend PivotalStoryFetcher
      when 2 then obj.extend PivotalTaskFetcher
      else
        raise "invalid sync_type: #{sync_type}"
      end
      obj.init_fetch
      obj
    end
  end

  def initialize from_db, options = {}
    self.user = UserData.new(from_db.integration_attributes)
    self.options = options
  end

  def fetch
    begin
      fetch_data if user.can_sync?
    rescue Exception => e
      logs user, e, "Fetcher error"
    ensure
      if user.can_sync?
        return user
      else
        return nil
      end
    end
  end

  def fetch_data
    teams.each do |t|
      sprints(t).each do |s|
        t.pivotal_sprints << s
      end
      user.pivotal_teams << t
    end
  end

  def logs(user, e, message)
    RestClient.log = '/tmp/restclient.log'
    logs = `tail -n 50 /tmp/restclient.log`
    ex = ExceptionEmail.new(:exception => e, :subject => message, :details => ["On user: #{user.inspect}", "Rest client logs: #{logs}"] )
    ::Notifier.error(ex).deliver
  end
end
