class User < ActiveRecord::Base
  include DevFriendly, Payment

  has_many :authentications, :dependent => :destroy
  has_many :teammates, :dependent => :destroy
  has_many :teams, :autosave => true, :through => :teammates
  has_many :notifications, :autosave => true, :dependent => :destroy
  has_many :subscriptions, :autosave => true, :dependent => :destroy
  before_destroy :cancel_subscription_if_present
  before_save :before_save_handler

  has_many :invitations
  has_one :preference_sheet, :autosave => true , :dependent => :destroy

  accepts_nested_attributes_for :teams
  # Setup accessible (or protected) attributes for your model
  attr_accessible :email, :name, :password, :password_confirmation, :remember_me, :current_password
  attr_accessor :current_password
  
  # Include default devise modules. Others available are:
  # :token_authenticatable, :encryptable, :confirmable, :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable, :confirmable

  def subscription
    subscriptions.sort_by{|s| s.created_at || DateTime.now }
      .reverse
      .first
  end
  
  def last_saved_subscription
    subscriptions.order('created_at DESC').first
  end

  def plan
    if subscription
      subscription.plan
    else
      Plan.find_by_name('basic')
    end
  end

  def preference_sheet
    @preference_sheet ||= PreferenceSheet.new(user_id: self.id)
    super || @preference_sheet
  end

  def picture_url
    @picture ||= Gravatar.new(email).image_url + '?d=mm'
  end

  def before_save_handler
    if subscription.nil?
      plan = Plan.find_by_name("basic")
      subscriptions << Subscription.new(:plan_id => plan.id, :user_id => id) 
    end
    add_local_auth if authentications.empty?
    set_user_name_from_email if name.blank?
  end
  
  def set_user_name_from_email
    write_attribute(:name, email.scan(/^[^@]*/).first)
  end
  
  def apply(omniauth, logged_in = false)
    provider = omniauth['provider']
    uid = omniauth['uid']
    
    write_attribute(:email, omniauth['info']['email']) if email.blank?
    authentications.build(:provider => provider, :uid => uid) unless authentications.any? { |a| a.provider == provider && a.uid == uid }
    
    #force a confirmation, the email we got does not come from the provider, only when record is not new
    unless new_record? || omniauth['info']['email'] || logged_in
      self.confirmed_at = nil 
      generate_confirmation_token
      Notifier.confirm_sync_of(self).deliver
    end
  end
  
  def transfer_and_remove!(other_user)
    unless self.email == other_user.email
      other_user.authentications.each { |a| authentications.build(:provider => a.provider,:uid => a.uid) }
      
      if other_user.has_local_auth?
        self.encrypted_password = other_user.encrypted_password 
        self.name = other_user.name
        self.email = other_user.email
      end
        
      skip_confirmation! if confirmation_required?
      yield if block_given? # logout?
      other_user.destroy
      save!  
    end
  end
  
  def add_local_auth
    authentications.build(:provider => 'manual signup', :uid => email)
  end

  def name_required?
    name.blank?
  end
  
  def password_required?
    has_local_auth? && super
  end
  
  def has_local_auth?
    authentications.empty? || authentications.any?{|x| x.is_local? }
  end
  
  def confirmation_required?
    confirmed_invitation = Invitation.any?{ |i| i.email == self.email && i.status == "validated" }
    last_auth = authentications.sort_by {|x| (x.created_at || Time.now) }.last || Authentication.new
  
    super && !confirmed_invitation && last_auth.confirmation_required? && use_email_validations?
  end
  
  def has_provider? provider
    authentications.any? { |a| a.provider == provider}
  end
  
  def unsync
    raise 'cannot unsync a user that is already confirmed' if confirmed?
    authentications.sort_by{|x| x.created_at}.last.destroy
    skip_confirmation!     
  end

  def can_make_private?
    self.plan.allows_private?
  end
end
