module Syncable
  def self.included(base)
    base.extend(ClassMethods)
  end

  module ClassMethods
    def do_not_update *args
      class_variable_set :@@do_not_update, [] unless class_variable_defined? :@@do_not_update
      update = class_variable_get :@@do_not_update
      args.each { |a| update << a }
    end

    def allow_delete value
      self.class_variable_set :@@delete, value 
    end
  end

  def accessible_attributes
    attributes.select{|k,v| k.to_sym != :integration_id && self.class.accessible_attributes.include?(k.to_s) }
  end
  
  def integration_attributes
    attributes.select{|k,v| self.class.accessible_attributes.include?(k.to_s) }
  end
  
  def equivalent_to? another
    equivalent = another.is_a?(Syncable) && 
    another.integration_id == integration_id &&
    another.accessible_attributes == accessible_attributes

    if equivalent
      equivalent = has_children? == another.has_children?
      if equivalent && has_children?
        children.zip(another.children).each do |a|
          a[0].equivalent_to?(a[1])
        end
      end
    end
    equivalent
  end

  def delete?
    if self.class.class_variable_defined? :@@delete   
      self.class.class_variable_get :@@delete
    else
      true
    end
  end
  
  def update_syncable_attributes_with attrs
    if self.class.class_variable_defined? :@@do_not_update
      filter = self.class.class_variable_get :@@do_not_update
      attrs = attrs.select{|k,v| !filter.include? k.to_sym }
    end
    update_attributes attrs
  end

  def to_hash
    hash = {}; self.attributes.select{|k,v| self.class.accessible_attributes.include?(k) }.each { |k,v| hash[k] = v }
  end

  def has_children?
    respond_to?(:children) && !children.empty?
  end
end

module Enumerable
  def equivalent_to?(another)
    another.is_a?(Enumerable) && 
    real_count == another.real_count && 
    zip(another).all?{|a| a[0].equivalent_to?(a[1]) } 
  end

  def real_count
    respond_to?(:length) ? length : count
  end
end
