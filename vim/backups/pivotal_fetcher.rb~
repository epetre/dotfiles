module PivotalFetcher
  def init_fetch
    self.host = user.integration_host
    self.token = user.integration_id 
    self.sync_count = options[:bypass_plans] ? 100 : user.sync_count
    self.projects_filter = user.team_integration_id_filter || []
    @fetch_iterations = {}
  end

  def api_url 
    @api_url ||= "https://#{host}/services/v3"
  end

  def request_header
    @request_header ||= {'X-TrackerToken' => token, 
     'X-Tracker-Use-UTC' => true,
     'Content-Type' => 'application/xml'}
  end

  def teams
    fetch_projects.select{ |p| integration_ids_to_sync.include? p['id'].to_s }
      .collect{|p| to_team p }
  end

  def to_team project_hash
    PivotalTeam.new(name: project_hash['name'], timezone: '-4', integration_id: project_hash['id'].to_s) 
  end

  def sprints team
    ids = integration_ids_to_sync[team.integration_id]
    fetch_iterations(team.integration_id)
      .select{|i| ids.include? i['id'].to_s}
      .collect{|i| to_sprint i, team }
      .compact
  end

  def build_sprint iteration
    finish = iteration['finish']
    start = iteration['start'].to_date
    duration = (finish - start).to_i + 1

    sprint = PivotalSprint.new name: "Iteration #{iteration['number']}",
      start_date: start, duration: duration, 
      include_weekend: true, integration_id: iteration['id'].to_s,
      is_private: true, last_sync_date: Time.now

    yield sprint if block_given?
    return nil if sprint.total_points == 0
    sprint
  end

  def fetch_projects
    @fetch_projects ||= lambda{
      projects = Hash.from_xml(RestClient.get "#{api_url}/projects", request_header)['projects']
      projects = projects ? projects.compact : [] 
      filter_projects projects
    }.call
  end
  def filter_projects projects
    projects = projects.select{|p| projects_filter.include? p['id'].to_s} unless projects_filter.empty?
    projects
  end

  def available_team_integration_ids
    @available_ids ||= lambda do  
      projects = Hash.from_xml(RestClient.get "#{api_url}/projects", request_header)['projects']
      projects = projects ? projects.compact : [] 
      projects.collect{|p| [p['name'], p['id']]} 
    end.call
  end

  ProjectContainer = Struct.new(:project_id, :iteration_id, :start)
  def integration_ids_to_sync
    @integration_ids_to_sync ||= lambda do
      potential = fetch_projects.inject([]) do |sum, p|
        pots = fetch_iterations(p['id'].to_s)
          .select{ |i| i['stories'].any? }
          .sort_by{ |x| x['start'] }
          .reverse
          .take(sync_count)
          .map { |i| ProjectContainer.new(p['id'].to_s, i['id'].to_s, i['start']) }
        sum.concat(pots)
      end
      potential = potential.sort_by{ |x| x.start }
        .reverse
        .take(sync_count)

      Hash[potential.group_by(&:project_id).map{|k,v| [k, v.collect(&:iteration_id)]}]
    end.call
  end

  def fetch_iterations project_id
    @fetch_iterations[project_id] ||= lambda{
      iterations_url = "#{api_url}/projects/#{project_id}/iterations"
      [Hash.from_xml(RestClient.get "#{iterations_url}/done", 
                     request_header)['iterations'], 
       Hash.from_xml(RestClient.get "#{iterations_url}/current", 
                     request_header)['iterations']].flatten.compact
    }.call
  end

  @@max_progress_length ||= Progress.validators_on(:description)[0].options[:maximum]
  @@marked_story_types ||= {'bug' => 'B', 'chore' => 'C', 'feature' => 'F'}
  def description story_name, story_type
    identifier = story_type_identifier story_type
    max = @@max_progress_length - identifier.length

    if identifier.blank?
      story_name[0...max]
    else
      "#{identifier} #{story_name[0...(max - 1)]}"
    end
  end

  def story_type_identifier story_type
    identifier = @@marked_story_types[story_type] 
    identifier ? "[#{identifier}]" : ''
  end
end
